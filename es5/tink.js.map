{"version":3,"sources":["../es6/tink.js"],"names":[],"mappings":"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","file":"tink.js","sourcesContent":["class Tink {\n  constructor(element, scale = 1) {\n\n    //Add element and scale properties\n    this.element = element;\n    this.scale = scale;\n\n    //An array to store all the draggable sprites\n    this.draggableSprites = [];\n\n    //An array to store all the pointer objects\n    //(there will usually just be one)\n    this.pointers = [];\n  }\n\n  //`makeDraggable` lets you make a drag-and-drop sprite by pushing it\n  //into the `draggableSprites` array\n  makeDraggable(...sprites) {\n    sprites.forEach(sprite => {\n      this.draggableSprites.push(sprite);\n      sprite.draggable = true;\n    });\n  }\n\n  //`makeUndraggable` removes the sprite from the `draggableSprites`\n  //array\n  makeUndraggable(...sprites) {\n    sprites.forEach(sprite => {\n      this.draggableSprites.splice(this.draggableSprites.indexOf(sprite), 1);\n      sprite.undraggable = false;\n    });\n  }\n\n  makePointer(element = this.element, scale = this.scale) {\n\n    //Get a reference to Tink's global `draggableSprites` array\n    let draggableSprites = this.draggableSprites;\n\n    //Get a reference to Tink's `addGlobalPositionProperties` method\n    let addGlobalPositionProperties = this.addGlobalPositionProperties;\n\n    //The pointer object will be returned by this function\n    let pointer = {\n      element: element,\n      scale: scale,\n\n      //Private x and y properties\n      _x: 0,\n      _y: 0,\n\n      //The public x and y properties are divided by the scale. If the\n      //HTML element that the pointer is sensitive to (like the canvas)\n      //is scaled up or down, you can change the `scale` value to\n      //correct the pointer's position values\n      get x() {\n        return this._x / this.scale;\n      },\n      get y() {\n        return this._y / this.scale;\n      },\n\n      //Add `centerX` and `centerY` getters so that we\n      //can use the pointer's coordinates with easing\n      //and collision functions\n      get centerX() {\n        return this.x; \n      },\n      get centerY() {\n        return this.y;\n      },\n\n      //`position` returns an object with x and y properties that\n      //contain the pointer's position\n      get position() {\n        return {x: this.x, y: this.y};\n      },\n\n      //Add a `cursor` getter/setter to change the pointer's cursor\n      //style. Values can be \"pointer\" (for a hand icon) or \"auto\" for \n      //an ordinary arrow icon.\n      get cursor(value) {\n        return this.element.style.cursor;\n      },\n      set cursor(value) {\n        this.element.style.cursor = value;\n      },\n      \n      //Booleans to track the pointer state\n      isDown: false,\n      isUp: true,\n      tapped: false,\n\n      //Properties to help measure the time between up and down states\n      downTime: 0,\n      elapsedTime: 0,\n\n      //Optional `press`,`release` and `tap` methods\n      press: undefined,\n      release: undefined,\n      tap: undefined,\n\n      //A `dragSprite` property to help with drag and drop\n      dragSprite: null,\n\n      //The drag offsets to help drag sprites\n      dragOffsetX: 0,\n      dragOffsetY: 0,\n      \n      //The pointer's mouse `moveHandler`\n      moveHandler(event) {\n\n        //Get the element that's firing the event\n        let element = event.target;\n\n        //Find the pointer’s x and y position (for mouse).\n        //Subtract the element's top and left offset from the browser window\n        this._x = (event.pageX - element.offsetLeft);\n        this._y = (event.pageY - element.offsetTop);\n\n        //Prevent the event's default behavior \n        event.preventDefault();\n      },\n\n      //The pointer's `touchmoveHandler`\n      touchmoveHandler(event) {\n        let element = event.target;\n\n        //Find the touch point's x and y position\n        this._x = (event.targetTouches[0].pageX - element.offsetLeft);\n        this._y = (event.targetTouches[0].pageY - element.offsetTop);\n        event.preventDefault();\n      },\n\n      //The pointer's `downHandler`\n      downHandler(event) {\n\n        //Set the down states\n        this.isDown = true;\n        this.isUp = false;\n        this.tapped = false;\n\n        //Capture the current time\n        this.downTime = Date.now();\n\n        //Call the `press` method if it's been assigned\n        if (this.press) this.press();\n        event.preventDefault();\n      },\n\n      //The pointer's `touchstartHandler`\n      touchstartHandler(event) {\n        let element = event.target;\n\n        //Find the touch point's x and y position\n        this._x = event.targetTouches[0].pageX - element.offsetLeft;\n        this._y = event.targetTouches[0].pageY - element.offsetTop;\n\n        //Set the down states\n        this.isDown = true;\n        this.isUp = false;\n        this.tapped = false;\n\n        //Capture the current time\n        this.downTime = Date.now();\n\n        //Call the `press` method if it's been assigned\n        if (this.press) this.press();\n        event.preventDefault();\n      },\n\n      //The pointer's `upHandler`\n      upHandler(event) {\n\n        //Figure out how much time the pointer has been down\n        this.elapsedTime = Math.abs(this.downTime - Date.now());\n\n        //If it's less than 200 milliseconds, it must be a tap or click\n        if (this.elapsedTime <= 200 && this.tapped === false) {\n          this.tapped = true;\n\n          //Call the `tap` method if it's been assigned\n          if (this.tap) this.tap(); \n        }\n        this.isUp = true;\n        this.isDown = false;\n\n        //Call the `release` method if it's been assigned\n        if (this.release) this.release();\n        event.preventDefault();\n      },\n\n      //The pointer's `touchendHandler`\n      touchendHandler(event) {\n\n        //Figure out how much time the pointer has been down\n        this.elapsedTime = Math.abs(this.downTime - Date.now());\n\n        //If it's less than 200 milliseconds, it must be a tap or click\n        if (this.elapsedTime <= 200 && this.tapped === false) {\n          this.tapped = true;\n\n          //Call the `tap` method if it's been assigned\n          if (this.tap) this.tap(); \n        }\n        this.isUp = true;\n        this.isDown = false;\n\n        //Call the `release` method if it's been assigned\n        if (this.release) this.release();\n        event.preventDefault();\n      },\n\n      //`hitTestSprite` figures out if the pointer is touching a sprite\n      hitTestSprite(sprite) {\n\n        //Add global `gx` and `gy` properties to the sprite if they\n        //don't already exist\n        addGlobalPositionProperties(sprite);\n          \n        //The `hit` variable will become `true` if the pointer is\n        //touching the sprite and remain `false` if it isn't\n        let hit = false;\n\n        //Is the sprite rectangular?\n        if (!sprite.circular) {\n\n          //Get the position of the sprite's edges using global\n          //coordinates\n          let left = sprite.gx,\n              right = sprite.gx + sprite.width,\n              top = sprite.gy,\n              bottom = sprite.gy + sprite.height;\n\n          //Find out if the pointer is intersecting the rectangle.\n          //`hit` will become `true` if the pointer is inside the\n          //sprite's area\n          hit \n            = this.x > left && this.x < right \n            && this.y > top && this.y < bottom;\n        }\n\n        //Is the sprite circular?\n        else {\n          \n          //Find the distance between the pointer and the\n          //center of the circle\n          let vx = this.x - (sprite.gx + sprite.width / 2),\n              vy = this.y - (sprite.gy + sprite.width / 2),\n              distance = Math.sqrt(vx * vx + vy * vy);\n\n          //The pointer is intersecting the circle if the\n          //distance is less than the circle's radius\n          hit = distance < sprite.width / 2;\n        }\n        return hit;\n      }\n    };\n\n    //Bind the events to the handlers\n    //Mouse events\n    element.addEventListener(\n      \"mousemove\", pointer.moveHandler.bind(pointer), false\n    );\n    element.addEventListener(\n      \"mousedown\", pointer.downHandler.bind(pointer), false\n    );\n    \n    //Add the `mouseup` event to the `window` to\n    //catch a mouse button release outside of the canvas area\n    window.addEventListener(\n      \"mouseup\", pointer.upHandler.bind(pointer), false\n    );\n\n    //Touch events\n    element.addEventListener(\n      \"touchmove\", pointer.touchmoveHandler.bind(pointer), false\n    );\n    element.addEventListener(\n      \"touchstart\", pointer.touchstartHandler.bind(pointer), false\n    );\n\n    //Add the `touchend` event to the `window` object to\n    //catch a mouse button release outside of the canvas area\n    window.addEventListener(\n      \"touchend\", pointer.touchendHandler.bind(pointer), false\n    );\n\n    //Disable the default pan and zoom actions on the `canvas`\n    element.style.touchAction = \"none\";\n\n    //Add the pointer to Tink's global `pointers` array\n    this.pointers.push(pointer);\n\n    //Return the pointer\n    return pointer;\n  }\n\n  //Many of Tink's objects, like pointers, use collision\n  //detection using the sprites' global x and y positions. To make\n  //this easier, new `gx` and `gy` properties are added to sprites\n  //that reference Pixi sprites' `getGlobalPosition()` values.\n  addGlobalPositionProperties(sprite) {\n    if (sprite.gx === undefined) {\n      Object.defineProperty(\n        sprite, \n        \"gx\", \n        {\n          get() {return sprite.getGlobalPosition().x;}\n        }\n      );\n    } \n\n    if (sprite.gy === undefined) {\n      Object.defineProperty(\n        sprite, \n        \"gy\", \n        {\n          get() {return sprite.getGlobalPosition().y;}\n        }\n      );\n    } \n  }\n\n  //A method that implments drag-and-drop functionality \n  //for each pointer\n  updateDragAndDrop(draggableSprites) {\n\n    //Create a pointer if one doesn't already exist\n    if (this.pointers.length === 0) {\n      this.makePointer(this.element, this.scale);\n    }\n\n    //Loop through all the pointers in Tink's global `pointers` array\n    //(there will usually just be one, but you never know)\n    this.pointers.forEach(pointer => {\n\n      //Check whether the pointer is pressed down\n      if (pointer.isDown) {\n\n        //You need to capture the co-ordinates at which the pointer was\n        //pressed down and find out if it's touching a sprite\n\n        //Only run pointer.code if the pointer isn't already dragging\n        //sprite\n        if (pointer.dragSprite === null) {\n\n          //Loop through the `draggableSprites` in reverse to start searching at the bottom of the stack\n          for (let i = draggableSprites.length - 1; i > -1; i--) {\n\n            //Get a reference to the current sprite\n            let sprite = draggableSprites[i];\n\n            //Check for a collision with the pointer using `hitTestSprite`\n            if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n\n              //Calculate the difference between the pointer's\n              //position and the sprite's position\n              pointer.dragOffsetX = pointer.x - sprite.gx;\n              pointer.dragOffsetY = pointer.y - sprite.gy;\n\n              //Set the sprite as the pointer's `dragSprite` property\n              pointer.dragSprite = sprite;\n\n              //The next two lines re-order the `sprites` array so that the\n              //selected sprite is displayed above all the others.\n              //First, splice the sprite out of its current position in\n              //its parent's `children` array\n              let children = sprite.parent.children;\n              children.splice(children.indexOf(sprite), 1);\n\n              //Next, push the `dragSprite` to the end of its `children` array so that it's\n              //displayed last, above all the other sprites\n              children.push(sprite);\n\n              //Reorganize the `draggableSpites` array in the same way\n              draggableSprites.splice(draggableSprites.indexOf(sprite), 1);\n              draggableSprites.push(sprite);\n\n              //Break the loop, because we only need to drag the topmost sprite\n              break;\n            }\n          }\n        } \n        \n        //If the pointer is down and it has a `dragSprite`, make the sprite follow the pointer's\n        //position, with the calculated offset\n        else {\n          pointer.dragSprite.x = pointer.x - pointer.dragOffsetX;\n          pointer.dragSprite.y = pointer.y - pointer.dragOffsetY;\n        }\n      }\n\n      //If the pointer is up, drop the `dragSprite` by setting it to `null`\n      if (pointer.isUp) {\n        pointer.dragSprite = null;\n      }\n\n      //Change the mouse arrow pointer to a hand if it's over a\n      //draggable sprite\n      draggableSprites.some(sprite => {\n        if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n          pointer.cursor = \"pointer\";\n          return true;\n        } else {\n          pointer.cursor = \"auto\";\n          return false;\n        }\n      });\n    });\n  }\n\n  //Run the `udpate` function in your game loop\n  //to update all of Tink's interactive objects\n  update() {\n    \n    //Update the drag and drop system\n    if (this.draggableSprites.length !== 0) this.updateDragAndDrop(this.draggableSprites);\n  }\n}\n"]}